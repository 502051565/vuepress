---
title: 二进制
date: 2024-02-26 18:46:54
permalink: /pages/24hq01/
categories:
  - jvm
tags:
  - jvm
---
# 二进制

[[toc]]

## 1.有符号数据表示法

### 什么是有符号数？

所谓有符号数就是数据有正负之分就是有符号数，数据无正负之分就是无符号数。
例如：**+7**，**-7**就是有符号数
有符号数的组成
*符号位**+**数值位（例如：**int i=+7**）* (0 00000000000000000000000000000000111)

***
### 为什么要有有符号数？

因为在计算机内，有符号数有**3**种表示法：原码，反码和补码。并且所有的数据运算都是采用补码进行的。

## 2.原码、补码、反码？

### 什么是原码？

就是二进制点表示法，即最高位为符号位，**“0”**表示正，**“1”**表示负，其余位表示数值的大小。

### 什么是反码？

正数的反码与其原码相同，负数的反码是对其原码逐位取反，但符号位除外。

### 什么是补码？

*正数的补码与其原码相同，负数的补码与其反码相加后再加**1**相同。*

*换句话说，负数的补码是通过对其原码取反（反码），然后加上**1**来获得的。*

*补码的一个重要特性是对于任意一个整数**n**，它的补码与**-n**的补码相同。例如，**-2**的补码是与**2**的补码相同的。*



````java
//+7和-7在计算机中是如何存储的?
//有符号数由两部分组成：
//1.符号位（二进制的最左表的一位表示的是符号位，0表示正数，1表示负数）
//2.数值位
//int类型的表数范围：2的32次方个数字
//                -2的31次方法 到+2的31次方-1
````

````java
//int i=+7;
int i =0b00000000000000000000000000000111;
System.out.println(i);//7

//int j=-7;
//-7的二进制位
//0b10000000000000000000000000000111;
int j =0b10000000000000000000000000000111;//-2147483641 不是-7 那为什么呢？
//计算机中存储有符号数的时候是按照补码的形式存进去的。
//此数据0b10000000000000000000000000000111;不是二进制的补码，而是二进制的原码
System.out.println(j);//-2147483641
````

````java
		/**
         * 计算中中所有的有符号数据都是按照补码的形式存储的
         * 正数的原码、反码、补码都是一样的
         * 负数是原码、反码、补码是不一样的
         *
         * 什么是原码？就是符号位+数值位（数据的绝对值）
         * 什么是反码？反码就是除符号位不变，其他位全部1变0,0变1
         * 什么是补码？补码就是在反码的基础上+1，就是补码
         *
         */

        /**
         * +7
         * 原码：0b00000000000000000000000000000111
         * 反码：0b00000000000000000000000000000111
         * 补码：0b00000000000000000000000000000111
         */

        /**
         * -7
         * 原码：0b10000000000000000000000000000111
         * 反码：0b11111111111111111111111111111000
         * 补码：0b11111111111111111111111111111001
         *
         */
        int k=0b11111111111111111111111111111001;//-7的补码
        /**
         * 计算机在显示给咱们看的时候，会把补码转化成原码
         * 怎么转？
         * 补码-1得到反码 反码再取反得到的就是原码（符号位不变）
         * 剩下的除符号位不变，其余的0变1,1变0
         * 补码：0b11111111111111111111111111111001
         * 反码：0b11111111111111111111111111111000
         * 原码：0b10000000000000000000000000000111
         *
         */
        System.out.println(k);//-7
````

## 3.位运算符种类

````java
/**
  * 位运算符种类
  * &:按位与 规则：两个同为1的时候才为1
  * |：按位或 规则：两个中只要有一个为1，那么结果为1
  * ^:按位异或 规则：两个不一样的时候才为1，如果一样，就位0
  * ~：按位取反 和逻辑非的意思是一样的 规则：1变0,0变1
  *
  * &，|，^:是双目运算符，操作数有两个
  * ~：单目运算符，操作数只有一个
*/
````

````java
/**
         * 注意：
         * 通过位运算的时候所有的操作数全部都是二进制，并且是补码！！！
         * 当显示给我们看的时候全部都是原码！！！
         */
````

````java
/**
         * 按位与 &
         * 3&4结果是多少？
         * 在进行位运算的时候，要把数据转换成二进制！并且全部都是二进制的补码形式！
         * &:按位与 规则：两个同为1的时候才为1
         * 3的二进制 ：   ob00000000000000000000000000000011
         * 4的二进制 ：   ob00000000000000000000000000000100
         * 3和4的按位与： ob00000000000000000000000000000000
         */

        int i=3&4;
        System.out.println(i);//0

        /**
         * 按位或 |
         * 3|4结果是多少？
         * 在进行位运算的时候，要把数据转换成二进制！并且全部都是二进制的补码形式！
         * |：按位或 规则：两个中只要有一个为1，那么结果为1
         * 3的二进制 ：   ob00000000000000000000000000000011
         * 4的二进制 ：   ob00000000000000000000000000000100
         * 3和4的按位或： ob00000000000000000000000000000111
         */

        int j=3|4;
        System.out.println(j);//7

        /**
         * 按位异或 ^
         * 3^4结果是多少？
         * 在进行位运算的时候，要把数据转换成二进制！并且全部都是二进制的补码形式！
         * ^:按位异或 规则：两个不一样的时候才为1，如果一样，就位0
         * 3的二进制 ：    ob00000000000000000000000000000011
         * 4的二进制 ：    ob00000000000000000000000000000100
         * 3和4的按位异或： ob00000000000000000000000000000111
         */

        int a=3^4;
        System.out.println(a);//7

        /**
         * 按位取反 ~
         * ~3结果是多少？
         * 在进行位运算的时候，要把数据转换成二进制！并且全部都是二进制的补码形式！
         * ~：按位取反 和逻辑非的意思是一样的 规则：1变0,0变1
         * 3的二进制 ：    ob00000000000000000000000000000011
         * 取反
         * 结果：         ob11111111111111111111111111111100   补码  负数
         * 已知补码求反码？补码-1之后取反（取反的过程中符号位不变）
         * 补码：原码取反+1（取反的过程中符号位不变）
         *
         * 补码：          ob11111111111111111111111111111100
         *             -                                   1
         *          ------------------------------------------
         *                ob11111111111111111111111111111011
         *   取反（原码）：  ob10000000000000000000000000000100
         */

        int b=~3;
        System.out.println(b);//-4


        /**
         * 按位异或常见应用：一般应用在加密上
         * 一个数据对相同的数据异或两次其值不变
         * 数据a
         * 数据b
         * a两次异或b 结果还是a
         * a^b^b == a
         *
         */

        int c=3;
        int d=4;
        System.out.println(c^d^d);//3


        /**
         * 实现两个变量值交换的方式一：通过一个中间量
         */

        int e=10;
        int f=20;
        int g;
        g=e;
        e=f;
        f=g;
        System.out.println(e);//20
        System.out.println(f);//10

        /**
         * 实现两个变量值交换的方式二：通过位运算实现
         * int aa=10;
         * int bb=20;
         * a=a^b;
         * b=a^b; b=a^b^b; (一个数据对相同的数据异或两次其值不变,所以值是a)
         * a=a^b; a=a^a^b; a^a=0  0^b=b;
         *
         */
        int aa=10;
        int bb=20;
        aa=aa^bb;
        bb=aa^bb;
        aa=aa^bb;
        System.out.println("aa"+aa);//aa20
        System.out.println("bb"+bb);//aa10

        /**
         * (（“0”^任何值）等于这个值,自己异或自己 等于 0)
         * 0 ^ 100 // 100
         * 100 ^ 100 // 0
         */

        int cc=10;

        System.out.println(0^cc);//10
        System.out.println(cc^cc);//0
````

````java
public static void main(String[] args) {
        /**
         * << :左移：让操作数乘以2的n次幂，n就是移动的次数
         * >> :右移：让操作数除以2的n次幂，n就是移动的次数
         * >>>:无符号右移
         *
         * 格式：
         * 操作数<<往左移动的位数
         * 操作数>>往右移动的位数
         * 操作数>>>往右移动的位数
         */

        //左移 <<
        int i;
        i=3<<2; //操作数 3 * 2^2 =12
        /**
         * 3<<2
         * 3的二进制位：
         *   00000000000000000000000000000011
         *   往左移动两位，右边就空出来两位！左边的两位就被挤掉了，右边空出来的两位用0补全
         *   00000000000000000000000000001100
         */
        System.out.println(i);//12

        //右移 >>
        i=32>>2; // 32/2^2=8;
        /**
         * 32>>2
         * 32的二进制位
         * 00000000000000000000000000100000
         * 往右移动两位，左边就空出来两位！右边的两位就被挤掉了，左边空出来的两位用0补全
         * 00000000000000000000000000001000
         *
         */
        System.out.println(i);//8

        /**
         * 无符号右移和左移的区别是：右移操作之后，左边会有空位出来，空位置用该操作数的符号位置的数补全，
         * 无符号右移，左边空出来的位置统统用0补全
         *
         * 结论：整数的无符号右移和右移的操作的结果是一样的
         *
         *
         *
         */

        i=32>>>2;//操作数 32/2^2 =8;
        System.out.println(i);//8

        i=-32>>>2;
        /**
         * 原码：10000000000000000000000000100000
         * 反码：11111111111111111111111111011111
         * 补码：11111111111111111111111111100000
         * 无符号右移两位
         *      00111111111111111111111111111000
         * 负数右移之后，变成了一个正数！
         *
         *
         */
        System.out.println(i);//1073741816

    }
````

